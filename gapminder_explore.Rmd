---
title: "Exploring Gapminder Data"
date: "16 October, 2015"
output:
  html_document:
    code_folding: hide
---

## Introduction

This report is the results of a quick exploration of the [Gapminder dataset](https://github.com/jennybc/gapminder), prepared as a part of [STAT545](http://stat545.com/) at UBC.

```{r setup, include=FALSE}
library(gplots)
library(ggplot2)
library(tidyr)
library(knitr)
library(MASS)
library(dplyr)
opts_chunk$set(warning=FALSE, messages=FALSE, cache=TRUE, fig.width = 4, fig.height = 3, cache=TRUE)
```

Since gapminder data is conveniently located online, don't need to download anything.

```{r, echo=TRUE}
gapminder <- read.delim(file = "http://www.stat.ubc.ca/~jenny/notOcto/STAT545A/examples/gapminder/data/gapminderDataFiveYear.txt")
```

### Plotting the slope of each country and it's intercept

I will calculate correlation of life expectancy vs year for each country. To quantify variability, I will extract the confidence interval of the slope.

```{r}
gapminder_regression <- gapminder %>% 
  group_by(continent, country) %>%
  do(model = lm(lifeExp ~ year, data = .)) %>%
  mutate(
    slope = coef(model)[2],
    ylo = confint(model)[2], # confidence interval of the slope
    yhi = confint(model)[4]
  )

kable(gapminder_regression %>% select(-model) %>% head(), format = "markdown")
```

```{r lm_cor_plot, echo=FALSE, fig.width=5, fig.height=15}
ggplot(gapminder_regression, aes(x=reorder(country, slope), y=slope, ymin=ylo, ymax=yhi, color = continent)) + 
#   facet_wrap(~ continent, scales = "free")+
  geom_pointrange()+
  coord_flip() + 
  geom_hline(yintercept=0, lty=2)
```

It seems like everybody is relatively similar - what happens if we use a robust linear model?

```{r}
gapminder_regression_robust <- gapminder %>% 
  group_by(continent, country) %>%
  do(model = rlm(formula = lifeExp ~ year, data = ., method = "MM")) %>%
  mutate(
    slope = coef(model)[2],
    ylo = confint(model)[2], # confidence interval of the slope
    yhi = confint(model)[4]
  )
```

Does robust slopes differ from non-robust slopes?

```{r lm_cor_diff, echo=FALSE, fig.width=5, fig.height=15}
normal_vs_robust <- rbind(gapminder_regression %>% mutate(id = "normal"),
                          gapminder_regression_robust %>% mutate(id = "robust"))

normal_vs_robust %>%
  ggplot(aes(x = slope, y = reorder(country, slope), color = id)) +
  geom_point()
```

Looks like some countries have a large difference in their slopes when using robust and non-robust methods. Let's see which ones?

```{r lm_rlm_diff_plot, fig.width=6}
slope_diff <- normal_vs_robust %>%
  group_by(continent, country) %>%
  summarize(slope_diff = max(slope) - min(slope))

kable(slope_diff %>% head(), format = "markdown")

cutoff = 0.1

slope_diff %>%
  ggplot(aes(slope_diff)) + geom_bar(binwidth=0.02) + geom_vline(xintercept = cutoff) + facet_wrap(~continent, nrow=1)
```

I will set a cutoff at 0.06 difference in slope. Presumably, countries beyond this difference means there is a lot of variability such that a robust method fits better (means there are outlier datapoints in years). Also, looks like Africa and Asia has these "outlier" countries - other continents don't. Africa also dominates in the count of countries.

Let's see which countries these are:

```{r}
(countries_of_interest <- filter(slope_diff, slope_diff > cutoff)$country %>% as.character())
```

Actually, I just realized that all this work is a very convoluted way to detect countries with outliers... Well anyway, moving on.

Now I want to plot these countries to see what's up with them. First, I'll make a function that returns (in a data.frame) the slope and intercepts for a normal model and a robust model.

```{r}
compare_models <- function(x) {
  model_lm <- lm(lifeExp ~ year, data = x)
  lm_df <- data.frame(slope = coef(model_lm)[2], intercept = coef(model_lm)[1], model = "normal")
  model_rlm <- rlm(lifeExp ~ year, data = x, method = "MM")
  rlm_df <- data.frame(slope = coef(model_rlm)[2], intercept = coef(model_rlm)[1], model = "robust")
  return(rbind(lm_df, rlm_df))
}

# Test this function

kable(compare_models(gapminder %>% filter(country == "Zimbabwe")), format = "markdown")
```

Works, great. Time to run this.

```{r lm_rlm_select_country, fig.width=10, fig.height=10}
gapminder_regression_interest <- gapminder %>% 
  group_by(continent, country) %>%
  do(compare_models(x = .)) %>% 
  filter(country %in% countries_of_interest)

kable(gapminder_regression_interest %>% head(), format="markdown")

inner_join(gapminder_regression_interest, gapminder) %>%
  ggplot(aes(x = year, y = lifeExp, color = model)) +
  geom_line(color = "black")+
  geom_abline(data = gapminder_regression_interest, aes(intercept = intercept, slope = slope, color = model)) +
  facet_wrap(continent~country, scales = "free")
```

For some reason a legend isn't showing. Red = "normal", blue = "robust".

Well, it seems like countries with outliers tend to suffer massive loss of LifeExp then bounce back - presumably war or natural disaster. Robust modelling results in a line that says "this is the life expectancy assuming nothing terrible happened" - which is pretty cool. I might come back to this and think of more interpretations.

### Clustering to see if we can identify classes of countries

Now, let's do some clustering to see if we can tease out what a developing country is.

First, I need to normalize all the "dimensions" in the data to the average so that distance calculations won't be skewed. For now, let's just work with 2007 data (I need to think of a way to incorporate all year data down the road).

```{r}
gapminder_averages <- gapminder %>%
  filter(year == 2007) %>%
  summarise_each(funs(mean, sd), pop, lifeExp, gdpPercap)

kable(gapminder_averages, format = "markdown")
```

Next, I will calculate the `z score` of each country in 2007, using the formula:

<img src="http://www.sciweavers.org/tex2img.php?eq=z%20%3D%20%5Cfrac%7Bvalue%20-%20mean%7D%7Bsd%7D%20&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0" align="center" border="0" alt="z = \frac{value - mean}{sd} " width="156" height="43" />

More information on what is a `z score` [here](https://en.wikipedia.org/wiki/Standard_score)

To do this, I make a function:

```{r}
gapminder_2007 <- gapminder %>% filter(year == 2007)

calc_z_score <- function(x) {
  pop_z <- (x$pop - gapminder_averages$pop_mean)/gapminder_averages$pop_sd
  lifeExp_z <- (x$lifeExp - gapminder_averages$lifeExp_mean)/gapminder_averages$lifeExp_sd
  gdpPercap_z <- (x$gdpPercap - gapminder_averages$gdpPercap_mean)/gapminder_averages$gdpPercap_sd
  return(data.frame(pop_z, lifeExp_z, gdpPercap_z))
}

# Test the function

calc_z_score(gapminder_2007 %>% filter(country == "Canada"))
```

Function works. Let's do this for every country now.

```{r}
gapminder_2007_z <- gapminder_2007 %>%
  group_by(country) %>%
  do(calc_z_score(.))

kable(gapminder_2007_z %>% head(), format = "markdown")
```

Now calculate a distance matrix. First, `dist` requires a numeric matrix.

```{r}
gapminder_zmatrix <- data.matrix(gapminder_2007_z[,2:4])
rownames(gapminder_zmatrix) <- gapminder_2007_z$country
```

Now, we cluster!

```{r cluster_tree, fig.height=5, fig.width=15}
mydist <- function(x) dist(x, method = "euclidian")
myhclust <- function(x) hclust(x, method = "ward.D2")

tree <- myhclust(mydist(gapminder_zmatrix))
plot(tree)
rect.hclust(tree, k = 5)
clustered_countries <- data.frame(country = names(cutree(tree, k = 5)), cluster = cutree(tree, k = 5))
```

Let's see the values (picked colors from [here](http://colorbrewer2.org/))

```{r clusters, fig.height=20, fig.width=8}
nbreaks=41
colors=colorRampPalette(c("#67001f", "#f7f7f7", "#053061"), bias = 1)(nbreaks)

label_colors <- c("#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026")

heatmap.2(gapminder_zmatrix,
          distfun=mydist,
          hclustfun=myhclust,
          RowSideColors = label_colors[clustered_countries$cluster],
          dendrogram = "row",
          Rowv=reorder(as.dendrogram(myhclust(mydist(gapminder_zmatrix))), wts=1:ncol(gapminder_zmatrix)),
          col = colors,
          trace = "none",
          margins = c(13,8))
```

Let's see the population, gdp and lifeExp of each of the clusters

```{r clusters_boxplots}
inner_join(clustered_countries, gapminder_2007) %>%
  gather(key = measure, value = value, ... = pop, gdpPercap, lifeExp) %>%
  tbl_df() %>%
  ggplot(aes(x = factor(cluster), y = value)) + geom_boxplot() + facet_wrap(~ measure, scales="free")
```

Looking at this, I conclude cluster 3 consists of first world countries. Who is part of this cluster?

```{r}
subset(clustered_countries, cluster == 3)$country
```

Yep, looks legit. It seems that using the three simple metrics `population`, `gdp per capita`, and `life expentancy`, one can classify countries into "first world", "third world" and etc.
